{"version":3,"file":null,"sources":["../../../src/scripts/stacked-menu.js"],"sourcesContent":["/**\n * A flexible stacked navigation menu.\n * @class\n *\n * @example <caption>The StackedMenu basic template looks like:</caption>\n * <div id=\"stacked-menu\" class=\"stacked-menu\">\n *   <nav class=\"menu\">\n *     <li class=\"menu-item\">\n *      <a href=\"home.html\" class=\"menu-link\">\n *        <i class=\"menu-icon fa fa-home\"></i>\n *        <span class=\"menu-text\">Home</span>\n *        <span class=\"badge badge-danger\">9+</span>\n *      </a>\n *     <li>\n *   </nav>\n * </div>\n *\n * @example <caption>Instance the StackedMenu:</caption>\n * var menus = new StackedMenu();\n */\nclass StackedMenu {\n\n  /**\n   * Create a StackedMenu.\n   * @constructor\n   * @param  {Object} options - An object containing key:value that representing the current StackedMenu.\n   */\n  constructor(options) {\n    /**\n     * The StackedMenu options.\n     * @type {Object}\n     * @property {Boolean} compact=false                  - Transform StackedMenu items (except item childs) to small size.\n     * @property {Boolean} hoverable=false                - How StackedMenu triggered `open`/`close` state. Use `false` for hoverable and `true` for collapsible (clickable).\n     * @property {Boolean} closeOther=true                - Control whether expanding an item will cause the other items to close. Only available when `hoverable=false`.\n     * @property {String} align='left'                    - Where StackedMenu items childs will open when `hoverable=true` (`left`/`right`).\n     * @property {String} selector='#stacked-menu'        - The StackedMenu element selector.\n     * @property {String} selectorClass='stacked-menu'    - The css class name that will be added to the StackedMenu and used for css prefix classes.\n     * @example\n     * var options = {\n     *   closeOther: false,\n     *   align: 'right',\n     * };\n     *\n     * var menus = new StackedMenu(options);\n     */\n    this.options = {\n      compact: false,\n      hoverable: false,\n      closeOther: true,\n      align: 'right',\n      selector: '#stacked-menu',\n      selectorClass: 'stacked-menu'\n    }\n\n    // mixed default and custom options\n    this.options = this._extend({}, this.options, options)\n\n    /**\n     * The StackedMenu element.\n     * @type {Element}\n     */\n    this.selector = document.querySelector(this.options.selector)\n\n    /**\n     * The StackedMenu items.\n     * @type {Element}\n     */\n    this.items = this.selector ? this.selector.querySelectorAll('.menu-item') : null\n\n    // forEach fallback\n    if (!Array.prototype.forEach) {\n      Array.prototype.forEach = function forEach(cb, arg) {\n        if(typeof cb !== 'function') throw new TypeError(`${cb} is not a function`)\n\n        let array = this\n        arg = arg || this\n        for(let i = 0; i < array.length; i++) {\n          cb.call(arg, array[i], i, array)\n        }\n      }\n    }\n    this.each = Array.prototype.forEach\n\n    /**\n     * Lists of feature classes that will be added to the StackedMenu depend to current options.\n     * Used selectorClass for prefix.\n     * @type {Object}\n     */\n    this.classes = {\n      alignLeft: this.options.selectorClass + '-has-left',\n      compact: this.options.selectorClass + '-has-compact',\n      collapsible: this.options.selectorClass + '-has-collapsible',\n      hoverable: this.options.selectorClass + '-has-hoverable',\n      hasChild: 'has-child',\n      hasActive: 'has-active',\n      hasOpen: 'has-open'\n    }\n\n    /** states element */\n    /**\n     * The active item.\n     * @type {Element}\n     */\n    this.active = null\n\n    /**\n     * The open item(s).\n     * @type {Element}\n     */\n    this.open = []\n\n    /** event handlers */\n    this.handlerClickDoc = []\n    this.handlerOver = []\n    this.handlerOut = []\n    this.handlerClick = []\n\n    // Initialization\n    this.init()\n  }\n\n  /** Private methods */\n  /**\n   * Listen on document when the page is ready.\n   * @private\n   * @param  {Function} handler - The callback function when page is ready.\n   * @return {void}\n   */\n  _onReady(handler) {\n    if(document.readyState != 'loading') {\n      handler()\n    } else {\n      document.addEventListener('DOMContentLoaded', handler, false)\n    }\n  }\n\n  /**\n   * Merge the contents of two or more objects together into the first object.\n   * @private\n   * @param  {Object} obj - An object containing additional properties to merge in.\n   * @return {Object} The merged object.\n   */\n  _extend(obj) {\n    obj = obj || {}\n    const args = arguments\n    for (let i = 1; i < args.length; i++) {\n      if (!args[i]) continue\n      for (let key in args[i]) {\n        if (args[i].hasOwnProperty(key))\n          obj[key] = args[i][key]\n      }\n    }\n    return obj\n  }\n\n  /**\n   * Attach an event to StackedMenu selector.\n   * @private\n   * @param  {String} type - The name of the event (case-insensitive).\n   * @param  {(Boolean|Number|String|Array|Object)} data - The custom data that will be added to event.\n   * @return {void}\n   */\n  _emit(type, data) {\n    let e\n    if (document.createEvent) {\n      e = document.createEvent('Event')\n      e.initEvent(type, true, true)\n    } else {\n      e = document.createEventObject()\n      e.eventType = type\n    }\n    e.eventName = type\n    e.data = data || this\n    // attach event to selector\n    document.createEvent\n      ? this.selector.dispatchEvent(e)\n      : this.selector.fireEvent('on' + type, e)\n  }\n\n  /**\n   * Bind one or two handlers to the element, to be executed when the mouse pointer enters and leaves the element.\n   * @private\n   * @param  {Element} el - The target element.\n   * @param  {Function} handlerOver - A function to execute when the mouse pointer enters the element.\n   * @param  {Function} handlerOut  - A function to execute when the mouse pointer leaves the element.\n   * @return {void}\n   */\n  _hover(el, handlerOver, handlerOut) {\n    if (el.tagName === 'A') {\n      this._on(el, 'focus', handlerOver)\n      this._on(el, 'blur', handlerOut)\n    } else {\n      this._on(el, 'mouseover', handlerOver)\n      this._on(el, 'mouseout', handlerOut)\n    }\n  }\n\n  /**\n   * Registers the specified listener on the element.\n   * @private\n   * @param  {Element} el - The target element.\n   * @param  {String} type - The name of the event.\n   * @param  {Function} handler - The callback function when event type is fired.\n   * @return {void}\n   */\n  _on(el, type, handler) {\n    let types = type.split(' ')\n    for (let i = 0; i < types.length; i++) {\n      el[window.addEventListener ? 'addEventListener' : 'attachEvent']( window.addEventListener ? types[i] : `on${types[i]}` , handler, false)\n    }\n  }\n\n  /**\n   * Removes the event listener previously registered with [_on()]{@link StackedMenu#_on} method.\n   * @private\n   * @param  {Element} el - The target element.\n   * @param  {String} type - The name of the event.\n   * @param  {Function} handler - The callback function when event type is fired.\n   * @return {void}\n   */\n  _off(el, type, handler) {\n    let types = type.split(' ')\n    for (let i = 0; i < types.length; i++) {\n      el[window.removeEventListener ? 'removeEventListener' : 'detachEvent']( window.removeEventListener ? types[i] : `on${types[i]}` , handler, false)\n    }\n  }\n\n  /**\n   * Adds one or more class names to the target element.\n   * @private\n   * @param {Element} el - The target element.\n   * @param {String} className - Specifies one or more class names to be added.\n   * @return {void}\n   */\n  _addClass(el, className) {\n    let classes = className.split(' ')\n    for (let i = 0; i < classes.length; i++) {\n      if (el.classList) el.classList.add(classes[i])\n      else el.classes[i] += ' ' + classes[i]\n    }\n  }\n\n  /**\n   * Removes one or more class names to the target element.\n   * @private\n   * @param {Element} el - The target element.\n   * @param {String} className - Specifies one or more class names to be added.\n   * @return {void}\n   */\n  _removeClass(el, className) {\n    let classes = className.split(' ')\n    for (let i = 0; i < classes.length; i++) {\n      if (el.classList) el.classList.remove(classes[i])\n      else el.classes[i] = el.classes[i].replace(new RegExp('(^|\\\\b)' + classes[i].split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ')\n    }\n  }\n\n  /**\n   * Determine whether the element is assigned the given class.\n   * @private\n   * @param {Element} el - The target element.\n   * @param {String} className - The class name to search for.\n   * @return {Boolean} is has className.\n   */\n  _hasClass(el, className) {\n    if (el.classList) return el.classList.contains(className)\n    return new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className)\n  }\n\n  /**\n   * Determine whether the element is a menu child.\n   * @private\n   * @param {Element} el - The target element.\n   * @return {Boolean} is has child.\n   */\n  _hasChild(el) {\n    return this._hasClass(el, this.classes.hasChild)\n  }\n\n  /**\n   * Determine whether the element is a active menu.\n   * @private\n   * @param {Element} el - The target element.\n   * @return {Boolean} is has active state.\n   */\n  _hasActive(el) {\n    return this._hasClass(el, this.classes.hasActive)\n  }\n\n  /**\n   * Determine whether the element is a open menu.\n   * @private\n   * @param {Element} el - The target element.\n   * @return {Boolean} is has open state.\n   */\n  _hasOpen(el) {\n    return this._hasClass(el, this.classes.hasOpen)\n  }\n\n  /**\n   * Determine whether the element is a level menu.\n   * @private\n   * @param {Element} el - The target element.\n   * @return {Boolean} is a level menu.\n   */\n  _isLevelMenu (el) {\n    return this._hasClass(el.parentNode.parentNode, this.options.selectorClass)\n  }\n\n  /**\n   * Attach an event to menu item depend on hoverable option.\n   * @private\n   * @param {Element} el - The target element.\n   * @param {Number} index - An array index from each menu item use to detach the current event.\n   * @return {void}\n   */\n  _menuTrigger(el, index) {\n    let elHover = el.querySelector('a')\n\n    // remove exist listener\n    this._off(el, 'mouseover', this.handlerOver[index])\n    this._off(el, 'mouseout', this.handlerOut[index])\n    this._off(elHover, 'focus', this.handlerOver[index])\n    this._off(elHover, 'blur', this.handlerOut[index])\n    this._off(el, 'click', this.handlerClick[index])\n\n    // handler listener\n    this.handlerOver[index] = this.openMenu.bind(this, el)\n    this.handlerOut[index] = this.closeMenu.bind(this, el)\n    this.handlerClick[index] = this.toggleMenu.bind(this, el)\n\n    // add listener\n    if (this.isHoverable()) {\n      if (this._hasChild(el)) {\n        this._hover(el, this.handlerOver[index], this.handlerOut[index])\n        this._hover(elHover, this.handlerOver[index], this.handlerOut[index])\n      }\n    } else {\n      this._on(el, 'click', this.handlerClick[index])\n    }\n  }\n\n  /**\n   * Handle for menu items interactions.\n   * @private\n   * @param {Element} items - The element of menu items.\n   * @return {void}\n   */\n  _handleInteractions(items) {\n    const self = this\n\n    this.each.call(items, (el, i) => {\n      if (self._hasChild(el)) {\n        self._menuTrigger(el, i)\n      }\n\n      if(self._hasActive(el)) self.active =  el\n    })\n  }\n\n  /**\n   * Get the parent menu item text of menu to be use on menu subhead.\n   * @private\n   * @param {Element} el - The target element.\n   * @return {void}\n   */\n  _getSubhead(el) {\n    return el.querySelector('.menu-text').textContent\n  }\n\n  /**\n   * Generate the subhead element for each child menu.\n   * @private\n   * @return {void}\n   */\n  _generateSubhead() {\n    const self = this\n    let menus = this.selector.children\n    let link, menu, subhead, label\n    this.each.call(menus, el => {\n      self.each.call(el.children, child => {\n        if (self._hasChild(child)) {\n          self.each.call(child.children, cc => {\n            if(self._hasClass(cc, 'menu-link')) link = cc\n          })\n\n          menu = link.nextElementSibling\n          subhead = document.createElement('li')\n          label = document.createTextNode(self._getSubhead(link))\n          subhead.appendChild(label)\n          self._addClass(subhead, 'menu-subhead')\n\n          menu.insertBefore(subhead, menu.firstChild)\n        }\n      })\n    })\n  }\n\n  /**\n   * Handle menu link tabindex depend on parent states.\n   * @return {void}\n   */\n  _handleTabIndex () {\n    const self = this\n    this.each.call(this.items, el => {\n      let container = el.parentNode.parentNode\n      if (!self._isLevelMenu(el)) {\n        el.querySelector('a').setAttribute('tabindex', '-1')\n      }\n      if (self._hasActive(container) || self._hasOpen(container)) {\n        el.querySelector('a').removeAttribute('tabindex')\n      }\n    })\n  }\n\n  /**\n   * Animate slide menu item.\n   * @private\n   * @param  {Object} el - The target element.\n   * @param  {String} direction - Up/Down slide direction.\n   * @param  {Number} speed - Animation Speed in millisecond.\n   * @param  {String} easing - CSS Animation effect.\n   * @return {Promise} resolve\n   */\n  _slide(el, direction, speed, easing) {\n    speed = speed || 300\n    easing = easing || 'ease'\n    let self = this\n    let menu = el.querySelector('.menu')\n    let es = window.getComputedStyle(el)['height']\n    // wait to resolve\n    let walkSpeed = speed + 50\n    // wait to clean style attribute\n    let clearSpeed = walkSpeed + 100\n\n    menu.style.transition = `height ${speed}ms ${easing}, opacity ${speed/2}ms ${easing}, visibility ${speed/2}ms ${easing}`\n\n    // slideDown\n    if (direction === 'down') {\n      // element\n      el.style.overflow = 'hidden'\n      el.style.height = es\n      // menu\n      menu.style.height = 'auto'\n      // get the current menu height\n      let height = window.getComputedStyle(menu)['height']\n      menu.style.height = 0\n      menu.style.visibility = 'hidden'\n      menu.style.opacity = 0\n      // remove element style\n      el.style.overflow = ''\n      el.style.height = ''\n\n      setTimeout(function() {\n        menu.style.height = height\n        menu.style.opacity = 1\n        menu.style.visibility = 'visible'\n      }, 0)\n    } else if (direction === 'up') {\n      // get the menu height\n      let height = window.getComputedStyle(menu)['height']\n      menu.style.height = height\n      menu.style.visibility = 'visible'\n      menu.style.opacity = 1\n\n      setTimeout(function() {\n        menu.style.height = 0\n        menu.style.visibility = 'hidden'\n        menu.style.opacity = 0\n      }, 0)\n    }\n\n    let done = new Promise(function(resolve) {\n      // remove the temporary styles\n      setTimeout(function() {\n        resolve(el)\n        // emit event\n        self._emit('menu:slide' + direction)\n      }, walkSpeed)\n    })\n\n    // remove styles after done has resolve\n    setTimeout(function() {\n      menu.removeAttribute('style')\n    }, clearSpeed)\n\n    return done\n  }\n\n  /** Public methods */\n  /**\n   * The first process that called after constructs the StackedMenu instance.\n   * @public\n   * @fires StackedMenu#menu:init\n   * @return {void}\n   */\n  init() {\n    const self = this\n    let opts = this.options\n\n    this._addClass(this.selector, opts.selectorClass)\n\n    // generate subhead\n    this._generateSubhead()\n\n    // implement compact feature\n    this.compact(opts.compact)\n    // implement hoverable feature\n    this.hoverable(opts.hoverable)\n\n    // handle menu link tabindex\n    this._handleTabIndex()\n\n    this.each.call(this.items, (el) => {\n      // stop propagation on each menu-link\n      self._on(el, 'click', function(e) {\n        e.stopPropagation()\n        // prevent default if has child\n        if (self._hasChild(el)) e.preventDefault()\n      })\n    })\n\n    // close on outside click, only on collapsible with compact mode\n    this._on(document.body, 'click', function () {\n      if (!self.isHoverable() && self.isCompact()) {\n        // handle listener\n        self.closeAllMenu()\n      }\n    })\n\n    // on ready state\n    this._onReady(() => {\n\n      /**\n       * This event is fired when the Menu has completed init.\n       *\n       * @event StackedMenu#menu:init\n       * @type {Object}\n       * @property {Object} data - The StackedMenu data instance.\n       *\n       * @example\n       * document.querySelector('#stacked-menu').addEventListener('menu:init', function(e) {\n       *   console.log(e.data);\n       * });\n       * @example <caption>Or using jQuery:</caption>\n       * $('#stacked-menu').on('menu:init', function() {\n       *   console.log('fired on menu:init!!');\n       * });\n       */\n      self._emit('menu:init')\n    })\n  }\n\n  /**\n   * Open/show the target menu item. This method didn't take effect to an active item if not on compact mode.\n   * @public\n   * @fires StackedMenu#menu:open\n   * @param {Element} el - The target element.\n   * @param {Boolean} emiter - are the element will fire menu:open or not.\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * var menuItem2 = menu.querySelectorAll('.menu-item.has-child')[1];\n   * menu.openMenu(menuItem2);\n   */\n  openMenu(el, emiter = true) {\n    // prevent open on active item if not on compact mode\n    if(this._hasActive(el) && !this.isCompact()) return\n    const self = this\n    let blockedSlide = this._isLevelMenu(el) && this.isCompact()\n\n    // open menu\n    if (this.isHoverable() || blockedSlide) {\n      this._addClass(el, this.classes.hasOpen)\n      // handle tabindex\n      this._handleTabIndex()\n    } else {\n      // slide down\n      this._slide(el, 'down', 150, 'linear').then(function() {\n        self._addClass(el, self.classes.hasOpen)\n        // handle tabindex\n        self._handleTabIndex()\n      })\n    }\n\n    this.open.push(el)\n\n    // child menu behavior\n    if (this.isHoverable() || (this.isCompact() && !this.hoverable())) {\n      const clientHeight = document.documentElement.clientHeight\n      const child = el.querySelector('.menu')\n      const pos = child.getBoundingClientRect()\n      const tolerance = pos.height - 20\n      const bottom = clientHeight - pos.top\n      const transformOriginX = this.options.align === 'left' ? '100%' : '0px'\n\n      if (pos.top >= 500 || tolerance >= bottom) {\n        child.style.top = 'auto'\n        child.style.bottom = 0\n        child.style.transformOrigin = `${transformOriginX} 100% 0`\n      }\n    }\n\n    /**\n     * This event is fired when the Menu has open.\n     *\n     * @event StackedMenu#menu:open\n     * @type {Object}\n     * @property {Object} data - The StackedMenu data instance.\n     *\n     * @example\n     * document.querySelector('#stacked-menu').addEventListener('menu:open', function(e) {\n     *   console.log(e.data);\n     * });\n     * @example <caption>Or using jQuery:</caption>\n     * $('#stacked-menu').on('menu:open', function() {\n     *   console.log('fired on menu:open!!');\n     * });\n     */\n    if (emiter) {\n      this._emit('menu:open')\n    }\n\n    return this\n  }\n\n  /**\n   * Close/hide the target menu item.\n   * @public\n   * @fires StackedMenu#menu:close\n   * @param {Element} el - The target element.\n   * @param {Boolean} emiter - are the element will fire menu:open or not.\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * var menuItem2 = menu.querySelectorAll('.menu-item.has-child')[1];\n   * menu.closeMenu(menuItem2);\n   */\n  closeMenu(el, emiter = true) {\n    const self = this\n    let blockedSlide = this._isLevelMenu(el) && this.isCompact()\n    // open menu\n    if (this.isHoverable() || blockedSlide) {\n      this._removeClass(el, this.classes.hasOpen)\n      // handle tabindex\n      this._handleTabIndex()\n    } else {\n      if (!this._hasActive(el)) {\n        // slide up\n        this._slide(el, 'up', 150, 'linear').then(function() {\n          self._removeClass(el, self.classes.hasOpen)\n          // handle tabindex\n          self._handleTabIndex()\n        })\n      }\n    }\n\n    this.each.call(this.open, (v, i) => {\n      if (el == v) self.open.splice(i, 1)\n    })\n\n    // remove child menu behavior style\n    if (this.isHoverable() || (this.isCompact() && !this.hoverable())) {\n      const child = el.querySelector('.menu')\n\n      child.style.top = ''\n      child.style.bottom = ''\n      child.style.transformOrigin = ''\n    }\n\n    /**\n     * This event is fired when the Menu has close.\n     *\n     * @event StackedMenu#menu:close\n     * @type {Object}\n     * @property {Object} data - The StackedMenu data instance.\n     *\n     * @example\n     * document.querySelector('#stacked-menu').addEventListener('menu:close', function(e) {\n     *   console.log(e.data);\n     * });\n     * @example <caption>Or using jQuery:</caption>\n     * $('#stacked-menu').on('menu:close', function() {\n     *   console.log('fired on menu:close!!');\n     * });\n     */\n    if (emiter) {\n      this._emit('menu:close')\n    }\n\n    return this\n  }\n\n  /**\n   * Close all opened menu items.\n   * @public\n   * @fires StackedMenu#menu:close\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * menu.closeAllMenu();\n   */\n  closeAllMenu() {\n    const self = this\n    this.each.call(this.items, el => {\n      if (self._hasOpen(el)) {\n        self.closeMenu(el, false)\n      }\n    })\n\n    return this\n  }\n\n  /**\n   * Toggle open/close the target menu item.\n   * @public\n   * @fires StackedMenu#menu:open\n   * @fires StackedMenu#menu:close\n   * @param {Element} el - The target element.\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * var menuItem2 = menu.querySelectorAll('.menu-item.has-child')[1];\n   * menu.toggleMenu(menuItem2);\n   */\n  toggleMenu(el) {\n    const method = this._hasOpen(el) ? 'closeMenu': 'openMenu'\n    const self = this\n    let itemParent, elParent\n\n    // close other\n    this.each.call(this.items, item => {\n      itemParent = item.parentNode.parentNode\n      elParent = el.parentNode.parentNode\n      // close other except parents that has open state and an active item\n      if(!self._hasOpen(elParent) && self._hasChild(itemParent)) {\n        if (self.options.closeOther || (!self.options.closeOther && self.isCompact())) {\n          if (self._hasOpen(itemParent)) {\n            self.closeMenu(itemParent, false)\n          }\n        }\n      }\n    })\n    // open target el\n    if (this._hasChild(el)) this[method](el)\n\n    return this\n  }\n\n  /**\n   * Set the open menu position to `left` or `right`.\n   * @public\n   * @fires StackedMenu#menu:align\n   * @param  {String} position - The position that will be set to the Menu.\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * menu.align('left');\n   */\n  align(position) {\n    const method = (position === 'left') ? '_addClass': '_removeClass'\n    const classes = this.classes\n\n    this[method](this.selector, classes.alignLeft)\n\n    this.options.align = position\n\n    /**\n     * This event is fired when the Menu has changed align position.\n     *\n     * @event StackedMenu#menu:align\n     * @type {Object}\n     * @property {Object} data - The StackedMenu data instance.\n     *\n     * @example\n     * document.querySelector('#stacked-menu').addEventListener('menu:align', function(e) {\n     *   console.log(e.data);\n     * });\n     * @example <caption>Or using jQuery:</caption>\n     * $('#stacked-menu').on('menu:align', function() {\n     *   console.log('fired on menu:align!!');\n     * });\n     */\n    this._emit('menu:align')\n\n    return this\n  }\n\n  /**\n   * Determine whether the Menu is currently compact.\n   * @public\n   * @return {Boolean} is compact.\n   *\n   * @example\n   * var isCompact = menu.isCompact();\n   */\n  isCompact() {\n    return this.options.compact\n  }\n\n  /**\n   * Toggle the Menu compact mode.\n   * @public\n   * @fires StackedMenu#menu:compact\n   * @param  {Boolean} isCompact - The compact mode.\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * menu.compact(true);\n   */\n  compact(isCompact) {\n    const method = (isCompact) ? '_addClass': '_removeClass'\n    const classes = this.classes\n\n    this[method](this.selector, classes.compact)\n\n    this.options.compact = isCompact\n    // reset interactions\n    this._handleInteractions(this.items)\n\n    /**\n     * This event is fired when the Menu has completed toggle compact mode.\n     *\n     * @event StackedMenu#menu:compact\n     * @type {Object}\n     * @property {Object} data - The StackedMenu data instance.\n     *\n     * @example\n     * document.querySelector('#stacked-menu').addEventListener('menu:compact', function(e) {\n     *   console.log(e.data);\n     * });\n     * @example <caption>Or using jQuery:</caption>\n     * $('#stacked-menu').on('menu:compact', function() {\n     *   console.log('fired on menu:compact!!');\n     * });\n     */\n    this._emit('menu:compact')\n\n    return this\n  }\n\n  /**\n   * Determine whether the Menu is currently hoverable.\n   * @public\n   * @return {Boolean} is hoverable.\n   *\n   * @example\n   * var isHoverable = menu.isHoverable();\n   */\n  isHoverable() {\n    return this.options.hoverable\n  }\n\n  /**\n   * Toggle the Menu (interaction) hoverable.\n   * @public\n   * @fires StackedMenu#menu:hoverable\n   * @param  {Boolean} isHoverable - `true` for hoverable and `false` for collapsible (clickable).\n   * @return {Object} The StackedMenu instance.\n   *\n   * @example\n   * menu.hoverable(true);\n   */\n  hoverable(isHoverable) {\n    const classes = this.classes\n\n    if (isHoverable) {\n      this._addClass(this.selector, classes.hoverable)\n      this._removeClass(this.selector, classes.collapsible)\n    } else {\n      this._addClass(this.selector, classes.collapsible)\n      this._removeClass(this.selector, classes.hoverable)\n    }\n\n    this.options.hoverable = isHoverable\n    // reset interactions\n    this._handleInteractions(this.items)\n\n    /**\n     * This event is fired when the Menu has completed toggle hoverable.\n     *\n     * @event StackedMenu#menu:hoverable\n     * @type {Object}\n     * @property {Object} data - The StackedMenu data instance.\n     *\n     * @example\n     * document.querySelector('#stacked-menu').addEventListener('menu:hoverable', function(e) {\n     *   console.log(e.data);\n     * });\n     * @example <caption>Or using jQuery:</caption>\n     * $('#stacked-menu').on('menu:hoverable', function() {\n     *   console.log('fired on menu:hoverable!!');\n     * });\n     */\n    this._emit('menu:hoverable')\n\n    return this\n  }\n}\n\nexport default StackedMenu\n"],"names":["StackedMenu","options","this","compact","hoverable","closeOther","align","selector","selectorClass","_extend","document","querySelector","items","querySelectorAll","Array","prototype","forEach","cb","arg","TypeError","array","let","i","length","call","each","classes","alignLeft","collapsible","hasChild","hasActive","hasOpen","active","open","handlerClickDoc","handlerOver","handlerOut","handlerClick","init","_onReady","handler","readyState","addEventListener","obj","args","arguments","key","hasOwnProperty","_emit","type","data","e","createEvent","initEvent","createEventObject","eventType","eventName","dispatchEvent","fireEvent","_hover","el","tagName","_on","types","split","window","_off","removeEventListener","_addClass","className","classList","add","_removeClass","remove","replace","RegExp","join","_hasClass","contains","test","_hasChild","_hasActive","_hasOpen","_isLevelMenu","parentNode","_menuTrigger","index","elHover","openMenu","bind","closeMenu","toggleMenu","isHoverable","_handleInteractions","self","_getSubhead","textContent","_generateSubhead","link","menu","subhead","label","menus","children","child","cc","nextElementSibling","createElement","createTextNode","appendChild","insertBefore","firstChild","_handleTabIndex","container","setAttribute","removeAttribute","_slide","direction","speed","easing","es","getComputedStyle","walkSpeed","clearSpeed","style","transition","overflow","height","visibility","opacity","setTimeout","done","Promise","resolve","opts","stopPropagation","preventDefault","body","isCompact","closeAllMenu","emiter","blockedSlide","then","push","clientHeight","documentElement","pos","getBoundingClientRect","tolerance","bottom","top","transformOriginX","transformOrigin","v","splice","itemParent","elParent","method","item","position"],"mappings":"YAoBA,IAAMA,aAAY,SAOJC,GAkBZC,KAAOD,SACLE,SAAW,EACXC,WAAa,EACbC,YAAc,EACdC,MAAS,QACTC,SAAY,gBACZC,cAAiB,gBAInBN,KAAOD,QAAUC,KAAKO,WAAYP,KAAKD,QAASA,GAMhDC,KAAOK,SAAWG,SAASC,cAAcT,KAAKD,QAAQM,UAMtDL,KAAOU,MAAQV,KAAKK,SAAWL,KAAKK,SAASM,iBAAiB,cAAgB,KAGvEC,MAAMC,UAAUC,UACrBF,MAAQC,UAAUC,QAAU,SAAiBC,EAAIC,GAC/C,GAAmB,kBAAPD,GAAmB,KAAM,IAAIE,WAAUF,uBAEnD,IAAMG,GAAQlB,IACdgB,GAAQA,GAAOhB,IACf,KAAMmB,GAAIC,GAAI,EAAGA,EAAIF,EAAMG,OAAQD,IACjCL,EAAKO,KAAKN,EAAKE,EAAME,GAAIA,EAAGF,KAIlClB,KAAOuB,KAAOX,MAAMC,UAAUC,QAO9Bd,KAAOwB,SACLC,UAAazB,KAAKD,QAAQO,cAAgB,YAC1CL,QAAWD,KAAKD,QAAQO,cAAgB,eACxCoB,YAAe1B,KAAKD,QAAQO,cAAgB,mBAC5CJ,UAAaF,KAAKD,QAAQO,cAAgB,iBAC1CqB,SAAY,YACZC,UAAa,aACbC,QAAW,YAQb7B,KAAO8B,OAAS,KAMhB9B,KAAO+B,QAGP/B,KAAOgC,mBACPhC,KAAOiC,eACPjC,KAAOkC,cACPlC,KAAOmC,gBAGPnC,KAAOoC,OAUTtC,uBAAEuC,kBAASC,GACmB,WAAvB9B,SAAS+B,WACZD,IAEA9B,SAAWgC,iBAAiB,mBAAoBF,GAAS,IAU7DxC,sBAAES,iBAAQkC,GACRA,EAAQA,KAER,KAAOtB,GADCuB,GAAOC,UACJvB,EAAI,EAAGA,EAAIsB,EAAKrB,OAAQD,IACjC,GAAOsB,EAAKtB,GACZ,IAAOD,GAAIyB,KAAOF,GAAKtB,GACfsB,EAAKtB,GAAGyB,eAAeD,KACzBH,EAAIG,GAAOF,EAAKtB,GAAGwB,GAG3B,OAASH,IAUX3C,sBAAEgD,eAAMC,EAAMC,GACZ,GAAMC,EACAzC,UAAS0C,aACbD,EAAMzC,SAAS0C,YAAY,SAC3BD,EAAIE,UAAUJ,GAAM,GAAM,KAE1BE,EAAMzC,SAAS4C,oBACfH,EAAII,UAAYN,GAElBE,EAAIK,UAAYP,EAChBE,EAAID,KAAOA,GAAQhD,KAEnBQ,SAAW0C,YACLlD,KAAKK,SAASkD,cAAcN,GAC5BjD,KAAKK,SAASmD,UAAU,KAAOT,EAAME,IAW7CnD,sBAAE2D,gBAAOC,EAAIzB,EAAaC,GACH,MAAfwB,EAAGC,SACP3D,KAAO4D,IAAIF,EAAI,QAASzB,GACxBjC,KAAO4D,IAAIF,EAAI,OAAQxB,KAEvBlC,KAAO4D,IAAIF,EAAI,YAAazB,GAC5BjC,KAAO4D,IAAIF,EAAI,WAAYxB,KAY/BpC,sBAAE8D,aAAIF,EAAIX,EAAMT,GAEd,IAAOnB,GADD0C,GAAQd,EAAKe,MAAM,KACd1C,EAAI,EAAGA,EAAIyC,EAAMxC,OAAQD,IAClCsC,EAAKK,OAAOvB,iBAAmB,mBAAqB,eAAgBuB,OAAOvB,iBAAmBqB,EAAMzC,GAAK,KAAKyC,EAAMzC,GAAOkB,GAAS,IAYxIxC,sBAAEkE,cAAKN,EAAIX,EAAMT,GAEf,IAAOnB,GADD0C,GAAQd,EAAKe,MAAM,KACd1C,EAAI,EAAGA,EAAIyC,EAAMxC,OAAQD,IAClCsC,EAAKK,OAAOE,oBAAsB,sBAAwB,eAAgBF,OAAOE,oBAAsBJ,EAAMzC,GAAK,KAAKyC,EAAMzC,GAAOkB,GAAS,IAWjJxC,sBAAEoE,mBAAUR,EAAIS,GAEd,IAAOhD,GADDK,GAAU2C,EAAUL,MAAM,KACrB1C,EAAI,EAAGA,EAAII,EAAQH,OAAQD,IAC9BsC,EAAGU,UAAWV,EAAGU,UAAUC,IAAI7C,EAAQJ,IACtCsC,EAAGlC,QAAQJ,IAAM,IAAMI,EAAQJ,IAW1CtB,sBAAEwE,sBAAaZ,EAAIS,GAEjB,IAAOhD,GADDK,GAAU2C,EAAUL,MAAM,KACrB1C,EAAI,EAAGA,EAAII,EAAQH,OAAQD,IAC9BsC,EAAGU,UAAWV,EAAGU,UAAUG,OAAO/C,EAAQJ,IACzCsC,EAAGlC,QAAQJ,GAAKsC,EAAGlC,QAAQJ,GAAGoD,QAAQ,GAAIC,QAAO,UAAYjD,EAAQJ,GAAG0C,MAAM,KAAKY,KAAK,KAAO,UAAW,MAAO,MAW5H5E,sBAAE6E,mBAAUjB,EAAIS,GACd,MAAMT,GAAGU,UAAkBV,EAAGU,UAAUQ,SAAST,GACxC,GAAIM,QAAO,QAAUN,EAAY,QAAS,MAAMU,KAAKnB,EAAGS,YASnErE,sBAAEgF,mBAAUpB,GACV,MAAS1D,MAAK2E,UAAUjB,EAAI1D,KAAKwB,QAAQG,WAS3C7B,sBAAEiF,oBAAWrB,GACX,MAAS1D,MAAK2E,UAAUjB,EAAI1D,KAAKwB,QAAQI,YAS3C9B,sBAAEkF,kBAAStB,GACT,MAAS1D,MAAK2E,UAAUjB,EAAI1D,KAAKwB,QAAQK,UAS3C/B,sBAAEmF,sBAAcvB,GACd,MAAS1D,MAAK2E,UAAUjB,EAAGwB,WAAWA,WAAYlF,KAAKD,QAAQO,gBAUjER,sBAAEqF,sBAAazB,EAAI0B,GACjB,GAAMC,GAAU3B,EAAGjD,cAAc,IAGjCT,MAAOgE,KAAKN,EAAI,YAAa1D,KAAKiC,YAAYmD,IAC9CpF,KAAOgE,KAAKN,EAAI,WAAY1D,KAAKkC,WAAWkD,IAC5CpF,KAAOgE,KAAKqB,EAAS,QAASrF,KAAKiC,YAAYmD,IAC/CpF,KAAOgE,KAAKqB,EAAS,OAAQrF,KAAKkC,WAAWkD,IAC7CpF,KAAOgE,KAAKN,EAAI,QAAS1D,KAAKmC,aAAaiD,IAG3CpF,KAAOiC,YAAYmD,GAASpF,KAAKsF,SAASC,KAAKvF,KAAM0D,GACrD1D,KAAOkC,WAAWkD,GAASpF,KAAKwF,UAAUD,KAAKvF,KAAM0D,GACrD1D,KAAOmC,aAAaiD,GAASpF,KAAKyF,WAAWF,KAAKvF,KAAM0D,GAGlD1D,KAAK0F,cACH1F,KAAK8E,UAAUpB,KACnB1D,KAAOyD,OAAOC,EAAI1D,KAAKiC,YAAYmD,GAAQpF,KAAKkC,WAAWkD,IAC3DpF,KAAOyD,OAAO4B,EAASrF,KAAKiC,YAAYmD,GAAQpF,KAAKkC,WAAWkD,KAGlEpF,KAAO4D,IAAIF,EAAI,QAAS1D,KAAKmC,aAAaiD,KAU9CtF,sBAAE6F,6BAAoBjF,GACpB,GAAQkF,GAAO5F,IAEfA,MAAOuB,KAAKD,KAAKZ,EAAO,SAACgD,EAAItC,GACrBwE,EAAKd,UAAUpB,IACnBkC,EAAOT,aAAazB,EAAItC,GAGrBwE,EAAKb,WAAWrB,KAAKkC,EAAK9D,OAAQ4B,MAU3C5D,sBAAE+F,qBAAYnC,GACZ,MAASA,GAAGjD,cAAc,cAAcqF,aAQ1ChG,sBAAEiG,4BACA,GAEMC,GAAMC,EAAMC,EAASC,EAFnBP,EAAO5F,KACToG,EAAQpG,KAAKK,SAASgG,QAE5BrG,MAAOuB,KAAKD,KAAK8E,EAAO,SAAA1C,GACtBkC,EAAOrE,KAAKD,KAAKoC,EAAG2C,SAAU,SAAAC,GACtBV,EAAKd,UAAUwB,KACnBV,EAAOrE,KAAKD,KAAKgF,EAAMD,SAAU,SAAAE,GAC1BX,EAAKjB,UAAU4B,EAAI,eAAcP,EAAOO,KAG/CN,EAASD,EAAKQ,mBACdN,EAAY1F,SAASiG,cAAc,MACnCN,EAAU3F,SAASkG,eAAed,EAAKC,YAAYG,IACnDE,EAAUS,YAAYR,GACtBP,EAAO1B,UAAUgC,EAAS,gBAE1BD,EAAOW,aAAaV,EAASD,EAAKY,kBAU1C/G,sBAAEgH,2BACA,GAAQlB,GAAO5F,IACfA,MAAOuB,KAAKD,KAAKtB,KAAKU,MAAO,SAAAgD,GAC3B,GAAMqD,GAAYrD,EAAGwB,WAAWA,UACzBU,GAAKX,aAAavB,IACvBA,EAAKjD,cAAc,KAAKuG,aAAa,WAAY,OAE7CpB,EAAKb,WAAWgC,IAAcnB,EAAKZ,SAAS+B,KAChDrD,EAAKjD,cAAc,KAAKwG,gBAAgB,eAc9CnH,sBAAEoH,gBAAOxD,EAAIyD,EAAWC,EAAOC,GAC7BD,EAAUA,GAAS,IACnBC,EAAWA,GAAU,MACrB,IAAMzB,GAAO5F,KACPiG,EAAOvC,EAAGjD,cAAc,SACxB6G,EAAKvD,OAAOwD,iBAAiB7D,GAAY,OAEzC8D,EAAYJ,EAAQ,GAEpBK,EAAaD,EAAY,GAK/B,IAHAvB,EAAOyB,MAAMC,WAAa,UAAUP,QAAWC,eAAmBD,EAAM,QAAOC,kBAAsBD,EAAM,QAAOC,EAG9F,SAAdF,EAAsB,CAE1BzD,EAAKgE,MAAME,SAAW,SACtBlE,EAAKgE,MAAMG,OAASP,EAEpBrB,EAAOyB,MAAMG,OAAS,MAEtB,IAAMA,GAAS9D,OAAOwD,iBAAiBtB,GAAc,MACrDA,GAAOyB,MAAMG,OAAS,EACtB5B,EAAOyB,MAAMI,WAAa,SAC1B7B,EAAOyB,MAAMK,QAAU,EAEvBrE,EAAKgE,MAAME,SAAW,GACtBlE,EAAKgE,MAAMG,OAAS,GAEpBG,WAAa,WACX/B,EAAOyB,MAAMG,OAASA,EACtB5B,EAAOyB,MAAMK,QAAU,EACvB9B,EAAOyB,MAAMI,WAAa,WACvB,OACE,IAAkB,OAAdX,EAAoB,CAE/B,GAAMU,GAAS9D,OAAOwD,iBAAiBtB,GAAc,MACrDA,GAAOyB,MAAMG,OAASA,EACtB5B,EAAOyB,MAAMI,WAAa,UAC1B7B,EAAOyB,MAAMK,QAAU,EAEvBC,WAAa,WACX/B,EAAOyB,MAAMG,OAAS,EACtB5B,EAAOyB,MAAMI,WAAa,SAC1B7B,EAAOyB,MAAMK,QAAU,GACpB,GAGP,GAAME,GAAO,GAAIC,SAAQ,SAASC,GAEhCH,WAAa,WACXG,EAAUzE,GAEVkC,EAAO9C,MAAM,aAAeqE,IACzBK,IAQP,OAJAQ,YAAa,WACX/B,EAAOgB,gBAAgB,UACpBQ,GAEIQ,GAUXnI,sBAAEsC,gBACA,GAAQwD,GAAO5F,KACToI,EAAOpI,KAAKD,OAElBC,MAAOkE,UAAUlE,KAAKK,SAAU+H,EAAK9H,eAGrCN,KAAO+F,mBAGP/F,KAAOC,QAAQmI,EAAKnI,SAEpBD,KAAOE,UAAUkI,EAAKlI,WAGtBF,KAAO8G,kBAEP9G,KAAOuB,KAAKD,KAAKtB,KAAKU,MAAO,SAACgD,GAE5BkC,EAAOhC,IAAIF,EAAI,QAAS,SAAST,GAC/BA,EAAIoF,kBAEEzC,EAAKd,UAAUpB,IAAKT,EAAEqF,qBAKhCtI,KAAO4D,IAAIpD,SAAS+H,KAAM,QAAS,YAC1B3C,EAAKF,eAAiBE,EAAK4C,aAEhC5C,EAAO6C,iBAKXzI,KAAOqC,SAAS,WAkBduD,EAAO9C,MAAM,gBAgBjBhD,sBAAEwF,kBAAS5B,EAAIgF,GAEb,mBAFsB,IAEjB1I,KAAK+E,WAAWrB,IAAQ1D,KAAKwI,YAAlC,CACA,GAAQ5C,GAAO5F,KACT2I,EAAe3I,KAAKiF,aAAavB,IAAO1D,KAAKwI,WAmBnD,IAhBMxI,KAAK0F,eAAiBiD,GAC1B3I,KAAOkE,UAAUR,EAAI1D,KAAKwB,QAAQK,SAElC7B,KAAO8G,mBAGP9G,KAAOkH,OAAOxD,EAAI,OAAQ,IAAK,UAAUkF,KAAK,WAC5ChD,EAAO1B,UAAUR,EAAIkC,EAAKpE,QAAQK,SAElC+D,EAAOkB,oBAIX9G,KAAO+B,KAAK8G,KAAKnF,GAGX1D,KAAK0F,eAAkB1F,KAAKwI,cAAgBxI,KAAKE,YAAc,CACnE,GAAQ4I,GAAetI,SAASuI,gBAAgBD,aACxCxC,EAAQ5C,EAAGjD,cAAc,SACzBuI,EAAM1C,EAAM2C,wBACZC,EAAYF,EAAInB,OAAS,GACzBsB,EAASL,EAAeE,EAAII,IAC5BC,EAA0C,SAAvBrJ,KAAKD,QAAQK,MAAmB,OAAS,OAE9D4I,EAAII,KAAO,KAAOF,GAAaC,KACnC7C,EAAQoB,MAAM0B,IAAM,OACpB9C,EAAQoB,MAAMyB,OAAS,EACvB7C,EAAQoB,MAAM4B,gBAAkBD,aAwBpC,MAJMX,IACJ1I,KAAO8C,MAAM,aAGN9C,OAeXF,sBAAE0F,mBAAU9B,EAAIgF,mBAAS,EACvB,IAAQ9C,GAAO5F,KACT2I,EAAe3I,KAAKiF,aAAavB,IAAO1D,KAAKwI,WAsBnD,IApBMxI,KAAK0F,eAAiBiD,GAC1B3I,KAAOsE,aAAaZ,EAAI1D,KAAKwB,QAAQK,SAErC7B,KAAO8G,mBAEA9G,KAAK+E,WAAWrB,IAErB1D,KAAOkH,OAAOxD,EAAI,KAAM,IAAK,UAAUkF,KAAK,WAC1ChD,EAAOtB,aAAaZ,EAAIkC,EAAKpE,QAAQK,SAErC+D,EAAOkB,oBAKb9G,KAAOuB,KAAKD,KAAKtB,KAAK+B,KAAM,SAACwH,EAAGnI,GACxBsC,GAAM6F,GAAG3D,EAAK7D,KAAKyH,OAAOpI,EAAG,KAI/BpB,KAAK0F,eAAkB1F,KAAKwI,cAAgBxI,KAAKE,YAAc,CACnE,GAAQoG,GAAQ5C,EAAGjD,cAAc,QAEjC6F,GAAQoB,MAAM0B,IAAM,GACpB9C,EAAQoB,MAAMyB,OAAS,GACvB7C,EAAQoB,MAAM4B,gBAAkB,GAuBlC,MAJMZ,IACJ1I,KAAO8C,MAAM,cAGN9C,MAYXF,sBAAE2I,wBACA,GAAQ7C,GAAO5F,IAOf,OANAA,MAAOuB,KAAKD,KAAKtB,KAAKU,MAAO,SAAAgD,GACrBkC,EAAKZ,SAAStB,IAClBkC,EAAOJ,UAAU9B,GAAI,KAIhB1D,MAeXF,sBAAE2F,oBAAW/B,GACX,GAEM+F,GAAYC,EAFVC,EAAS3J,KAAKgF,SAAStB,GAAM,YAAa,WAC1CkC,EAAO5F,IAmBf,OAfAA,MAAOuB,KAAKD,KAAKtB,KAAKU,MAAO,SAAAkJ,GAC3BH,EAAeG,EAAK1E,WAAWA,WAC/BwE,EAAahG,EAAGwB,WAAWA,YAErBU,EAAKZ,SAAS0E,IAAa9D,EAAKd,UAAU2E,KACxC7D,EAAK7F,QAAQI,aAAgByF,EAAK7F,QAAQI,YAAcyF,EAAK4C,cAC3D5C,EAAKZ,SAASyE,IAClB7D,EAAOJ,UAAUiE,GAAY,KAM/BzJ,KAAK8E,UAAUpB,IAAK1D,KAAK2J,GAAQjG,GAE9B1D,MAaXF,sBAAEM,eAAMyJ,GACN,GAAQF,GAAuB,SAAbE,EAAuB,YAAa,eAC9CrI,EAAUxB,KAAKwB,OAwBvB,OAtBAxB,MAAO2J,GAAQ3J,KAAKK,SAAUmB,EAAQC,WAEtCzB,KAAOD,QAAQK,MAAQyJ,EAkBvB7J,KAAO8C,MAAM,cAEJ9C,MAWXF,sBAAE0I,qBACA,MAASxI,MAAKD,QAAQE,SAaxBH,sBAAEG,iBAAQuI,GACR,GAAQmB,GAAUnB,EAAa,YAAa,eACpChH,EAAUxB,KAAKwB,OA0BvB,OAxBAxB,MAAO2J,GAAQ3J,KAAKK,SAAUmB,EAAQvB,SAEtCD,KAAOD,QAAQE,QAAUuI,EAEzBxI,KAAO2F,oBAAoB3F,KAAKU,OAkBhCV,KAAO8C,MAAM,gBAEJ9C,MAWXF,sBAAE4F,uBACA,MAAS1F,MAAKD,QAAQG,WAaxBJ,sBAAEI,mBAAUwF,GACV,GAAQlE,GAAUxB,KAAKwB,OAgCvB,OA9BMkE,IACJ1F,KAAOkE,UAAUlE,KAAKK,SAAUmB,EAAQtB,WACxCF,KAAOsE,aAAatE,KAAKK,SAAUmB,EAAQE,eAE3C1B,KAAOkE,UAAUlE,KAAKK,SAAUmB,EAAQE,aACxC1B,KAAOsE,aAAatE,KAAKK,SAAUmB,EAAQtB,YAG7CF,KAAOD,QAAQG,UAAYwF,EAE3B1F,KAAO2F,oBAAoB3F,KAAKU,OAkBhCV,KAAO8C,MAAM,kBAEJ9C"}